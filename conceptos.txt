üß† 1. Sesiones

Qu√© son:
Mecanismo para mantener el estado entre el cliente y el servidor despu√©s de un login.
El servidor guarda un registro en una base de datos (ej. sessions) y env√≠a al cliente un identificador √∫nico (session ID) dentro de una cookie.

C√≥mo funciona:
  -El usuario inicia sesi√≥n ‚Üí el servidor genera un sid.
  -El sid se guarda en la base con info del usuario, expiraci√≥n y token CSRF.
  -El navegador guarda el sid en una cookie.
  -En cada petici√≥n, el navegador env√≠a la cookie ‚Üí el servidor identifica al usuario.

Ventajas:
  -Permite invalidar sesiones (logout).
  -Facilita manejo centralizado (DB).
Desventajas:
  -Requiere guardar estado en el servidor.
  -No es ideal para APIs sin estado.

üîë 2. JWT (JSON Web Token)

Qu√© es:
Es un token en formato JSON firmado digitalmente (no cifrado) que representa informaci√≥n del usuario (ej. su id y rol).
Ejemplo: Authorization: Bearer <token>.

Partes:
-Header: tipo de token y algoritmo (HS256)
-Payload: datos del usuario (claims: sub, role, exp, etc.)
-Signature: hash firmado con una clave secreta (para verificar integridad).

Ventajas:
-No requiere guardar sesiones en el servidor (autenticaci√≥n sin estado).
-Ideal para APIs REST.

Desventajas:
-No se puede invalidar f√°cilmente hasta que expire.
-No se deben guardar datos sensibles dentro.

En este proyecto:
-Usamos jsonwebtoken con HS256 y un TTL de 15 minutos.
-El payload tiene { sub: id, role: 'user'|'admin' }.

üç™ 3. Cookies

Qu√© son:
Peque√±os datos que el servidor guarda en el navegador del cliente para mantener informaci√≥n entre peticiones (por ejemplo, la sesi√≥n).

Tipos usados aqu√≠:
-sid (session ID): identifica la sesi√≥n activa.
-csrfToken: token usado para protecci√≥n CSRF.

Propiedades importantes:
-HttpOnly: evita que el JS del cliente lea la cookie (mitiga XSS).
-Secure: solo se env√≠a por HTTPS (en dev lo dejamos en false).
-SameSite: previene env√≠o desde otros dominios (mitiga CSRF).

Ventajas:
-Persistentes (pueden durar varios d√≠as).

Desventajas:
-Si no se configuran correctamente, son vulnerables a ataques.

üßÇ 4. Hashing (bcrypt)

Qu√© es:
Proceso unidireccional que convierte una contrase√±a en un hash irreversible.
No se puede recuperar la contrase√±a original a partir del hash.

En este proyecto:
-Usamos bcryptjs con 12 rondas de encriptaci√≥n.
-Las contrase√±as se guardan solo como hash.
-En login, se compara usando bcrypt.compare().

üîí 5. Cifrado

Qu√© es:
Transformar datos legibles en ilegibles usando una clave.
A diferencia del hashing, el cifrado es reversible (se puede descifrar).

Uso aqu√≠:
-No ciframos contrase√±as (solo las hasheamos).
-Pero los JWT est√°n firmados, no cifrados, para garantizar integridad.

üß± 6. CSRF (Cross-Site Request Forgery)

Qu√© es:
Ataque donde un sitio malicioso hace que el navegador del usuario env√≠e solicitudes a otro sitio en el que est√° autenticado (usando sus cookies).

Ejemplo:
Si un usuario est√° logueado en PassPort, una p√°gina externa podr√≠a intentar enviar un POST /admin/delete usando sus cookies sin permiso.

Prevenci√≥n (Double Submit Cookie):
-El servidor env√≠a una cookie csrfToken + guarda ese token en DB.
-El cliente debe enviar ese valor tambi√©n en el encabezado X-CSRF-Token.
-El servidor compara cookie vs header; si no coinciden ‚Üí bloquea la petici√≥n.

En este proyecto:
-Cada sesi√≥n tiene su propio token CSRF.
-Middleware verifyCsrf valida token en todas las rutas sensibles.

‚öîÔ∏è 7. XSS (Cross-Site Scripting)

Qu√© es:
Inyecci√≥n de c√≥digo JavaScript malicioso en el navegador del usuario (por ejemplo, al mostrar un comentario sin sanitizar).

Ejemplo:
<script>alert('hack');</script> inyectado en un formulario.

Prevenci√≥n:
-Escapar o filtrar entradas del usuario.
-Usar cookies HttpOnly (evita robo de sesi√≥n).
-Helmet a√±ade cabeceras de seguridad (X-XSS-Protection, CSP).

En este proyecto:
-No se permite ejecuci√≥n de JS inline (salvo en dev).
-Helmet se usa para mitigar XSS y otras amenazas comunes.

üß± 8. RBAC (Role-Based Access Control)

Qu√© es:
Mecanismo para controlar qu√© acciones o rutas puede ejecutar cada usuario seg√∫n su rol.

Roles en este proyecto:

user: acceso a datos propios.

admin: puede listar usuarios y cambiar roles.

C√≥mo se aplica:
Middleware requireRole('admin') verifica el campo role del usuario antes de permitir acceso a rutas protegidas.

üß® 9. Protecci√≥n contra Fuerza Bruta

Qu√© es:
Mecanismo para evitar m√∫ltiples intentos de login con contrase√±as incorrectas.

Implementaci√≥n:

Contador failed_attempts en la tabla users.

A los 5 intentos fallidos, el usuario se bloquea 15 minutos (lock_until).

En login correcto, se resetea el contador.

üß¢ 10. Cabeceras HTTP de Seguridad 

Qu√© son:
Configuraciones en las respuestas HTTP que aumentan la seguridad del navegador.

Ejemplos (usadas con Helmet):

X-Content-Type-Options: nosniff

X-Frame-Options: DENY

Strict-Transport-Security

Content-Security-Policy (CSP)

En este proyecto:

En desarrollo, CSP est√° desactivada (contentSecurityPolicy:false) para permitir scripts externos.

En producci√≥n, se debe habilitar con una whitelist de scripts confiables.

üß© 11. Double Submit Cookie (CSRF Token Pattern)

Qu√© es:
Estrategia para prevenir CSRF sin guardar el token en sesi√≥n del servidor.

C√≥mo funciona:
-El servidor genera un token CSRF y lo env√≠a en una cookie.
-El cliente debe reenviar ese token como header en cada petici√≥n.
-El servidor compara ambos valores (cookie y header).

Ventaja:
Compatible con APIs sin estado y sesiones almacenadas en DB.

üßç‚Äç‚ôÇÔ∏è 12. Autenticaci√≥n vs Autorizaci√≥n

Autenticaci√≥n:
Verifica qui√©n eres (login con email y contrase√±a).

Autorizaci√≥n:
Verifica qu√© puedes hacer (rol: user o admin).

üíæ 13. SQLite y better-sqlite3

SQLite:
Base de datos ligera que guarda toda la informaci√≥n en un √∫nico archivo .db.

better-sqlite3:
M√≥dulo r√°pido y sincr√≥nico para manejar SQLite desde Node.js.

Ventajas:
-No requiere servidor externo.
-Ideal para prototipos o MVPs.

Uso aqu√≠:
-Guardamos users y sessions.
-Ejecutamos queries preparadas con db.prepare().

üß∞ 14. Helmet

Qu√© es:
Middleware que agrega cabeceras de seguridad HTTP.

Usos:
-Mitigar XSS, clickjacking, sniffing, etc.
-Configurar CSP (Content Security Policy).

En este proyecto:
-En dev: contentSecurityPolicy:false para permitir JS externo.
-En prod: habilitar CSP para m√°xima protecci√≥n.

üîê 15. Authorization Header

Qu√© es:
Cabecera HTTP donde el cliente env√≠a el token JWT.
Ejemplo:

Authorization: Bearer <token>


Funci√≥n:
Permite identificar al usuario en APIs sin estado.

En este proyecto:
Se usa en /me-jwt, /admin/users-jwt y /admin/users/:id/role-jwt.

üß© 16. CSRF + JWT

Los JWT no son vulnerables a CSRF si no se guardan en cookies (se env√≠an en headers).

En este proyecto, los JWT se env√≠an manualmente en Authorization, por lo tanto no necesitan token CSRF.

üßπ 17. Logout

Cookies:
Se eliminan sid y csrfToken, y se marca la sesi√≥n como revocada en DB.

JWT:
Basta con eliminar el token del cliente (no hay estado en el servidor).

‚öôÔ∏è 18. Content Security Policy (CSP)

Qu√© es:
Cabecera que define qu√© fuentes de scripts, estilos, im√°genes, etc., puede cargar el navegador.

Ejemplo:

Content-Security-Policy: default-src 'self';


En este proyecto:
Desactivada en dev para permitir los scripts de /views/*.js.

üìä 19. Expiraci√≥n y Revocaci√≥n

Sesiones (cookies):
Expiran tras 7 d√≠as o al revocarse (revoked_at).

JWT:
Expiran autom√°ticamente tras 15 minutos (exp claim).